(function(){let isRegistered=false;const runMe=function($dotapp){if(isRegistered){console.warn("DotApp Template Engine already registered, skipping...");return}isRegistered=true;class DotAppTemplateEngine{#cache=new Map;#pending=new Map;#renderers=new Map;#blocks=new Map;#basePath="/app/views/";constructor(){this.#registerCoreRenderers()}setBasePath(path){this.#basePath=path.endsWith("/")?path:path+"/";return this}getBasePath(){return this.#basePath}#registerCoreRenderers(){this.addRenderer("dotapp.foreach",async(code,data)=>{const pattern=/\{\{\s*foreach\s+\$([a-zA-Z_$][a-zA-Z0-9_$-]*)\s+as\s+\$([a-zA-Z_$][a-zA-Z0-9_$-]*)\s*\}\}(.*?)\{\{\s*\/foreach\s*\}\}/gs;const matches=[...code.matchAll(pattern)];let result=code;for(const match of matches){const[fullMatch,listKey,itemKey,inner]=match;const list=data[listKey]??[];if(!Array.isArray(list)){result=result.replace(fullMatch,"");continue}const renderedItems=await Promise.all(list.map(async item=>{const nested={...data,[itemKey]:item};return await this.#runAllRenderers(inner,nested)}));result=result.replace(fullMatch,renderedItems.join(""))}return result});this.addRenderer("dotapp.if",(code,data)=>{const pattern=/\{\{\s*(if|elseif|else|\/if)\s*(.*?)\s*\}\}/g;let result="";let current=code;let inIf=false;let matched=false;let ifStartIndex=0;while(true){const matches=[...current.matchAll(pattern)];if(matches.length===0){if(inIf&&!matched){result+=current}else if(!inIf){result+=current}break}const match=matches[0];const type=match[1].trim();const cond=match[2]?.trim();const before=current.slice(0,match.index);current=current.slice(match.index+match[0].length);if(type==="if"){if(inIf){if(matched){result+=before}}else{result+=before}inIf=true;matched=false;ifStartIndex=result.length;matched=this.#evalCondition(cond,data)}else if(type==="elseif"){if(!inIf){result+=before;continue}if(matched){result+=before}matched=this.#evalCondition(cond,data)}else if(type==="else"){if(!inIf){result+=before;continue}if(matched){result+=before}matched=true}else if(type==="/if"){if(inIf){if(matched){result+=before}}else{result+=before}inIf=false;matched=false}}if(!inIf){result+=current}return result});this.addRenderer("dotapp.block",(code,data)=>{const pattern=/\{\{\s*block:([\w.-]+)\s*\}\}(.*?)\{\{\s*\/block:\1\s*\}\}/gs;return code.replace(pattern,(match,name,content)=>{const fn=this.#blocks.get(name);return typeof fn==="function"?fn(content,[],data)||"":content})});this.addRenderer("dotapp.include",async(code,data)=>{const pattern=/\{\{\s*include\s+(?:'([^']+)'|"([^"]+)"|([^\s\}]+))\s*\}\}/g;const includes=[];let match;while((match=pattern.exec(code))!==null){const path=match[1]||match[2]||match[3];if(path){includes.push({placeholder:match[0],path:path.trim()})}}let result=code;for(const inc of includes){try{const partialCode=await this.#load(inc.path);const rendered=await this.#runAllRenderers(partialCode,data);result=result.replace(inc.placeholder,rendered)}catch(e){console.warn(`Failed to include template '${inc.path}':`,e);result=result.replace(inc.placeholder,`\x3c!-- Include failed: ${inc.path} --\x3e`)}}return result});this.addRenderer("dotapp.var",(code,data)=>code.replace(/\{\{\s*var:\s*\$([a-zA-Z_$][a-zA-Z0-9_$.-]*)\s*\}\}/g,(match,keyPath)=>{const keys=keyPath.split(".");let value=data;for(const key of keys){if(value===null||value===undefined){return""}value=value[key]}if(value===undefined||value===null){return""}if(typeof value!=="string")value=String(value);return value.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;").replace(/\$/g,"&#36;")}))}#evalCondition(cond,data){if(!cond)return true;try{const expr=cond.replace(/\$([a-zA-Z_$][a-zA-Z0-9_$.-]*)/g,(match,keyPath)=>{const keys=keyPath.split(".");let path="data";for(const key of keys){path+=`['${key}']`}return path});return new Function("data",`return !!(${expr});`)(data)}catch(e){console.warn("Invalid if condition:",cond,e);return false}}addRenderer(name,fn){this.#renderers.set(name,fn);return this}addBlock(name,fn){this.#blocks.set(name,fn);return this}async#runAllRenderers(code,data){let result=code;for(const fn of this.#renderers.values()){result=await fn(result,data)}return result}async#load(path){if(this.#cache.has(path))return this.#cache.get(path);if(this.#pending.has(path))return this.#pending.get(path);const fullPath=path.startsWith("/")?path:`${this.#basePath}${path}`;const url=fullPath.endsWith(".view.js")?fullPath:`${fullPath}.view.js`;const promise=fetch(url).then(r=>{if(!r.ok)throw new Error(`Template ${path} not found at ${url}`);return r.text()}).then(text=>{this.#cache.set(path,text);return text}).finally(()=>this.#pending.delete(path));this.#pending.set(path,promise);return promise}async render(element,path,dataOrVar){const template=await this.#load(path);let data={};let reactiveVar=null;if($dotapp().isInstanceOfDotAppVariable(dataOrVar)){reactiveVar=dataOrVar;data=reactiveVar.value||{}}else if(typeof dataOrVar==="string"){reactiveVar=$dotapp().getVariable(dataOrVar);data=reactiveVar?reactiveVar.value||{}:{}}else{data=dataOrVar||{}}const doRender=async()=>{const current=reactiveVar?reactiveVar.value||{}:data;element.innerHTML=await this.#runAllRenderers(template,current)};if(reactiveVar){reactiveVar.onChange(doRender)}await doRender()}}const engine=new DotAppTemplateEngine;$dotapp().fn("template",function(path,data){if(typeof path==="string"){this.getElements().forEach(el=>{engine.render(el,path,data).catch(err=>{console.error("Template rendering error:",err)})})}const self=this;return{addRenderer:function(name,fn){engine.addRenderer(name,fn);return self},addBlock:function(name,fn){engine.addBlock(name,fn);return self},setBasePath:function(path){engine.setBasePath(path);return self},getBasePath:function(){return engine.getBasePath()}}});window.dispatchEvent(new Event("dotapp-template-ready"))};if(window.$dotapp){runMe(window.$dotapp)}else{window.addEventListener("dotapp-register",()=>runMe(window.$dotapp),{once:true})}})();